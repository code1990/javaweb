第1节:什么是java并发编程.mp4
第2节:并发工具类有哪些.mp4
第3节:课程文档资料.pdf
第4节:线程池介绍.mp4
第5节:增减线程的时机.mp4
第6节:keepAliveTime和线程工厂.mp4
第7节:演示内存溢出的情况.mp4
第8节:线程池用法演示.mp4
第9节:对比线程池的特点.mp4
第10节:五虎上将收服线程池.mp4
第11节:钩子-给线程池加点料.mp4
第12节:Executor家族的辨析.mp4
第13节:线程池状态和使用注意点.mp4
第14节:ThreadLocal的两种用法.mp4
第15节:进化之路-故事从两个线程说起.mp4
第16节:进化之路-线程池来帮忙，却好心办坏事.mp4
第17节:走过的弯路，你的套路.mp4
第18节:ThreadLocal是救火队长.mp4
第19节:悔不当初-回顾进化之路.mp4
第20节:ThreadLocal的第二种用法 part1.mp4
第21节:ThreadLocal的第二种用法 part2.mp4
第22节:ThreadLocal的两种用法总结.mp4
第23节:ThreadLocal的好处.mp4
第24节:ThreadLocal原理.mp4
第25节:ThreadLocal的重要方法介绍.mp4
第26节:重要方法的源码分析.mp4
第27节:两种场景，殊途同归.mp4
第28节:收不回来的value.mp4
第29节:ThreadLocal的空指针异常问题.mp4
第30节:ThreadLocal在Spring中的应用.mp4
第31节:本章纵览.mp4
第32节:内置锁的能力不足以满足需求.mp4
第33节:tryLock尝试获取锁.mp4
第34节:代码演示-获取锁时被中断.mp4
第35节:锁的可见性保证.mp4
第36节:互斥同步锁.mp4
第37节:非互斥同步锁.mp4
第38节:可重入锁的用法.mp4
第39节:可重入性质和源码解析.mp4
第40节:是否允许一部分人“先富起来”.mp4
第41节:代码演示-先来后到的特例、优劣、源码分析.mp4
第42节:共享锁和排它锁的用法.mp4
第43节:深入理解交互思想.mp4
第44节:看似读锁按部就班.mp4
第45节:超越95%面试者的秘籍 part 1.mp4
第46节:超越95%面试者的秘籍 part 2.mp4
第47节:读写锁的由奢入俭“易”.mp4
第48节:循环尝试，不释放CPU.mp4
第49节:可中断锁.mp4
第50节:我们如何才能让锁变得更好用？.mp4
第51节:“锁”事总结.mp4
第52节:什么是原子类，有什么作用？.mp4
第53节:6类原子类纵览.mp4
第54节:AtomicInteger案例演示.mp4
第55节:Atomic数组，每个都安全.mp4
第56节:Atomic引用在自旋锁的应用.mp4
第57节:把普通变量升级为原子变量.mp4
第58节:对比新旧工具的运行速度.mp4
第59节:剖析高速运转的原理.mp4
第60节:功能升级，不限于加操作.mp4
第61节:总结原子类.mp49 \8 W- V2 ~% ^$ I8 K% C
第62节:什么是CAS.mp4
第63节:CAS的等价代码、使用案例.mp4
第64节:CAS的应用场景、源码分析.mp4
第65节:CAS的缺点和总结.mp4
第66节:什么是“不变性”？.mp4
第67节:final变量的赋值时机.mp4
第68节:final的注意点.mp4
第69节:栈封闭技术.mp4
第70节:面试题-真假美猴王.mp4
第71节:并发容器概览.mp4
第72节:集合类的历史，演进过程-Vector和Hashtable.mp4
第73节:前身-同步的HashMap和ArrayList.mp4
第74节:ConcurrentHashMap概览.mp4
第75节:Map接口的典型实现类、常用方法演示.mp4
第76节:彩蛋-调整JDK版本，以便查看对应版本的代码.mp4
第77节:HashMap的死循环导致CPU100%的问题分析.mp4
第78节:彩蛋-多线程调试技巧，每个线程独立调试.mp4
第79节:HashMap的死循环分析.pdf
第80节:HashMap 1.7和1.8的结构图和特点，红黑树的概念.mp4
第81节:ConcurrentHashMap 1.7和1.8结构图.mp4
第82节:ConcurrentHashMap源码分析-.mp4
第83节:ConcurrentHashMap1.7和1.8的对比，做了哪些升级？.mp4
第84节:ConcurrentHashMap难道也会发生线程安全问题？-组合操作的玄机.mp4
第85节:实际生产中并发安全事故的分享、ConcurrentHashMap复习.mp4
第86节:CopyOnWriteArrayList的适用场景、读写规则.mp4
第87节:CopyOnWrite设计理念、数据过期问题.mp4
第88节:CopyOnWrite源码、缺点分析.mp4
第89节:并发队列简介.mp4
第90节:彩蛋-轻松绘制漂亮的UML图.mp4
第91节:BlockingQueue入门.mp4
第92节:ArrayBlockingQueue代码演示、源码分析.mp4
第93节: LinkedBlockingQueue等典型介绍.mp4
第94节:并发容器总结.mp4
第95节:如何控制并发流程？.mp4
第96节:倒计时门闩，一等多.mp4
第97节:综合用法-运动员跑步.mp4
第98节:Semaphore颁发许可证.mp4
第99节:Semaphore用法和注意点.mp4
第100节:条件对象的作用和用法演示.mp4
第101节:用条件对象实现生产者模式.mp4
第102节:循环栅栏的作用.mp4
第103节:总结控制并发流程的要点.mp4
第104节:如何学习AQS？.mp4
第105节:Semaphore和AQS的关系.mp4
第106节:比喻-HR和AQS的职责统一.mp4
第107节:AQS的三要素.mp4
第108节:AQS源码分析.mp4
第109节:AQS的许可证颁发.mp4
第110节:利用AQS实现独占锁.mp4
第111节: DIY一次性门闩.mp4
第112节:AQS的核心思路.mp4
第113节:AQS补充材料.pdf
第114节:Future和Callable的关系.mp4
第115节:代码演示-submit返回Future对象，快速抽取返回值.mp4
第116节:批量接收结果.mp4
第117节:执行时异常和isDone演示.mp4
第118节:代码演示-默认广告的超时和取消.mp4
第119节:cancel方法与中断线程.mp4
第120节:用法二-用FutureTask获取结果.mp4
第121节:总结Future本章.mp4y
第122节:从最简单的缓存出发.mp4
第123节:暴露出来的性能和复用性问题.mp4
第124节:用装饰者模式解耦.mp4
第125节:用ConcurrentHashMap保证并发安全.mp4
第126节:用Future解决重复计算问题.mp4
第127节:原子组合操作填补漏洞.mp4
第128节:计算错误如何处理？.mp4
第129节:缓存污染问题的解决.mp4
第130节:缓存过期功能和随机性.mp4
第131节:用线程池测试缓存性能.mp4
第132节:用CountDownLatch实现压测.mp4
第133节:用ThreadLocal确认时间的统一性.mp4
第134节:知识点总结.mp4
第135节:conclusion 1.mp4
第136节:conclusion 2.mp4
资料文档.zip

缓存, 面试, 源码解析
本主题由 admin 于 2020-4-23 16:46 设置高亮